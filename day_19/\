package main

import (
	"fmt"
	"os"
	"strings"
)

func Fatal(err error) {
	if err != nil {
		panic(err)
	}
}

type OreRobot struct {
	oreCost int
}

type ClayRobot struct {
	oreCost int
}

type ObsidianRobot struct {
	oreCost  int
	clayCost int
}

type GeodeRobot struct {
	oreCost      int
	obsidianCost int
}

type Recipe struct {
	Id            int
	OreRobot      OreRobot
	ClayRobot     ClayRobot
	ObsidianRobot ObsidianRobot
	GeodeRobot    GeodeRobot
}

/*
Parse recipes from a string:
Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 2: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 19 clay. Each geode robot costs 4 ore and 15 obsidian.
Blueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 8 clay. Each geode robot costs 3 ore and 9 obsidian.
*/
func ParseRecipes(input []string) []Recipe {
	recipes := make([]Recipe, 0)
	for i, line := range input {
		oreRobot := OreRobot{}
		clayRobot := ClayRobot{}
		obsidianRobot := ObsidianRobot{}
		geodeRobot := GeodeRobot{}
		fmt.Println("line:", line)
		_, err := fmt.Sscanf(line, "Blueprint %d: Each ore robot costs %d ore. Each clay robot costs %d ore. Each obsidian robot costs %d ore and %d clay. Each geode robot costs %d ore and %d obsidian.", &i, &oreRobot.oreCost, &clayRobot.oreCost, &obsidianRobot.oreCost, &obsidianRobot.clayCost, &geodeRobot.oreCost, &geodeRobot.obsidianCost)
		Fatal(err)
		recipes = append(recipes, Recipe{
			Id:            i,
			OreRobot:      oreRobot,
			ClayRobot:     clayRobot,
			ObsidianRobot: obsidianRobot,
			GeodeRobot:    geodeRobot,
		})
	}
	return recipes
}

/*
open file Argv[1] using os.ReadFile.
split data into lines, remove last empty line.
parse recipes from lines.
*/
func main() {
	data, err := os.ReadFile(os.Args[1])
	Fatal(err)
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		fmt.Println("Line:", line)
	}
	recipes := ParseRecipes(lines)
	fmt.Println(recipes)
}
